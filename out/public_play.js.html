<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: public/play.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: public/play.js</h1>






    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Game settings read from local storage on the browser
 */
var settings = JSON.parse(localStorage.getItem('Settings'));
var hiscores = JSON.parse(localStorage.getItem('Score'));
console.log('Settings: ' + settings);
console.log('Scores: ' + hiscores);
var gameType = settings.gametype;
var gameMode = settings.gamemode;
var gameLevel = settings.gamelevel;
var fieldWidth = settings.fieldwidth;
var fieldHeight = settings.fieldheight;

/**
 * Creates the initial 20X10 gameboard.
 */
var grid = [
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
];

/**
 * Tetronimo shape and color definitions for different gametypes
 */
var shapes;
var colors;
var shapes1 = {
    I: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
    J: [[2,0,0], [2,2,2], [0,0,0]],
    L: [[0,0,3], [3,3,3], [0,0,0]],
    O: [[4,4], [4,4]],
    S: [[0,5,5], [5,5,0], [0,0,0]],
    T: [[0,6,0], [6,6,6], [0,0,0]],
    Z: [[7,7,0], [0,7,7], [0,0,0]],
};
               //blue    //green   //yellow  //orange  //red     //purple  //pink
var colors1 = ["539bf5", "57ab5a", "c69026", "cc6b2c", "e5534b", "986ee2", "c96198"];

var shapes2 = {
    I: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
    J: [[2,0,0], [2,2,2], [0,0,0]],
    L: [[0,0,3], [3,3,3], [0,0,0]],
    O: [[4,4], [4,4]],
    S: [[0,5,5], [5,5,0], [0,0,0]],
    T: [[0,6,0], [6,6,6], [0,0,0]],
    Z: [[7,7,0], [0,7,7], [0,0,0]],
    Y: [[0,8,0], [0,8,8], [0,0,0]],
    H: [[0,0,0], [9,9,9], [0,0,0]],
};
              //blue    //green   //yellow  //orange  //red     //purple  //pink    //dblue   //dgreen
var colors2 = ["539bf5", "57ab5a", "c69026", "cc6b2c", "e5534b", "986ee2", "c96198", "1b4b91", "245829"];

if (gameType) {
    shapes = shapes2;
    colors = colors2;
} else {
    shapes = shapes1;
    colors = colors1;
}

/**
 * Game state variables
 */
// game and paused document elements for controling pause game behaviour
// var gameElem = document.getElementById("game");
// var pauseElem = document.getElementById("paused");
// var overElem = document.getElementById("over");
// var hiscoreElem = document.getElementById("hiscore");
//coordinates and shape parameter of current block we can update
var currentShape = {x: 0, y: 0, shape: undefined};
//store shape of upcoming block
var upcomingShape;
//stores shapes
var bag = [];
//index for shapes in the bag
var bagIndex = 0;
//Used to help create a seeded generated random number for choosing shapes. makes results deterministic (reproducible) for debugging
var rndSeed = 1;
//Game score
var score = 0;
// Lines eliminated
var lines = 0;
// boolean for changing game speed
var changeSpeed = false;
//for storing current state, we can load later
var saveState;
//stores current game state
var roundState;
// list of level titles
levels = ['BEGINNER', 'NORMAL', 'HARD', 'PRO', 'INSANE']
//list of available game speeds
var speeds = [1000,500,250,100,1,];
//inded in game speed array
var speedIndex = gameLevel;
// game speed
var speed = speeds[speedIndex];
//turn ai on or off
var ai = gameMode;
// game starts paused unless ai playing
var pause = false;
// if (ai) {
//     pause = false;
// }
//drawing game vs updating algorithms
var draw = true;
//how many so far?
var movesTaken = 0;
//max number of moves allowed in a generation
var moveLimit = 500;
//consists of move the 7 move parameters
var moveAlgorithm = {};
//set to highest rate move
var inspectMoveSelection = false;


/**
 * Genetic algorithm values, used to mutate the AI behaviour
 */
//stores number of genomes, init at 50
var populationSize = 50;
//stores genomes
var genomes = [];
//index of current genome in genomes array
var currentGenome = -1;
//generation number
var generation = 0;
//stores values for a generation
var archive = {
    populationSize: 0,
    currentGeneration: 0,
    elites: [],
    genomes: []
};
//rate of mutation
var mutationRate = 0.05;
//helps calculate mutation
var mutationStep = 0.2;


/**
 * Main game loop, manages the game state and timing of drawing to the screen
 */
function initialize() {
    //init pop size
    archive.populationSize = populationSize;
    //get the next available shape from the bag
    nextShape();
    //applies the shape to the grid
    applyShape();
    //set both save state and current state from the game
    saveState = getState();
    roundState = getState();
    //create an initial population of genomes
    // createInitialPopulation();
    loadArchive("ai.js")

    // main game loop
    var loop = function(){
        // while (pause === true) {
        //     console.log('yup');
        //     setTimeout(loop, 10);
        // }
        //boolean for changing game speed
        if (changeSpeed) {
            //restart the clock
            //stop time
            clearInterval(interval);
            //set time, like a digital watch
            interval = setInterval(loop, speed);
            //and don't change it
            changeInterval = false;
        }
        if (speed === 0) {
            //no need to draw on screen elements
            draw = false;
            //updates the game (update fitness, make a move, evaluate next move)
            update();
            update();
            update();
        } else {
            //draw the elements
            draw = true;
        }
        //update regardless
        update();
        if (speed === 0) {
            //now draw elements
            draw = true;
            //now update the score
            updateScore();
        }
    };
    //timer interval
    var interval = setInterval(loop, speed);
    // pause game
    // while (pause) {
    //     await pauseGame(100);
    // }
}
document.onLoad = initialize();


/**
 * Enables keyboard input based on Player or AI game mode.
 */
window.onkeydown = async function (event) {

    var characterPressed = String.fromCharCode(event.keyCode);
    if (event.keyCode == 27) {
        pause = true;
        pauseMenu();
    }
    if (ai) {
        if (characterPressed.toUpperCase() == "W") {
            //speed up
            speedIndex++;
            if (speedIndex >= speeds.length) {
                speedIndex = 0;
            }
            //adjust speed index
            speed = speeds[speedIndex];
            changeSpeed = true;
        } else if (characterPressed.toUpperCase() == "S") {
            //slow down
            speedIndex--;
            if (speedIndex &lt; 0) {
                speedIndex = speeds.length - 1;
            }
            speed = speeds[speedIndex];
            changeSpeed = true;
        } else if (characterPressed.toUpperCase() == "F") {
            // show AI Move selection parameters
            inspectMoveSelection = !inspectMoveSelection;
        } else {
            return true;
        }
    } else {
        if (event.keyCode == 38) {
            rotateShape();
        } else if (event.keyCode == 40) {
            moveDown();
        } else if (event.keyCode == 37) {
            moveLeft();
        } else if (event.keyCode == 39) {
            moveRight();
        } else if (event.keyCode == 13) {
            pause = false;
        } else if (characterPressed.toUpperCase() == "W") {
            //speed up
            speedIndex++;
            if (speedIndex >= speeds.length) {
                speedIndex = 0;
            }
            speed = speeds[speedIndex];
            changeSpeed = true;
        } else if (characterPressed.toUpperCase() == "S") {
            //slow down
            speedIndex--;
            if (speedIndex &lt; 0) {
                speedIndex = speeds.length - 1;
            }
            speed = speeds[speedIndex];
            changeSpeed = true;
        } else {
            return true;
        }
    }
    //outputs game state to the screen (post key press)
    output();
    return false;
};

function pauseGame(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// async function wait() {

// }

function pauseMenu() {
    document.getElementById("game").hidden = true;
    document.getElementById("pause").hidden = false;
    document.getElementById("yes").addEventListener(
        "click",
        () => {
            pause = false;
            document.getElementById("pause").hidden = true;
            document.getElementById("game").hidden = false;
        },
        false
    );
    // document.getElementById("no").addEventListener(
    //     "click",
    //     () => {
    //         pause = false;
    //         document.getElementById("pause").hidden = true;
    //         document.getElementById("game").hidden = false;
    //     },
    //     false
    // );
}

function gameOver() {
    document.getElementById("game").hidden = true;
    document.getElementById("over").hidden = false;
    checkHiScore();
    document.getElementById("yes").addEventListener(
        "click",
        () => {
            reset();
            paused = false;
            document.getElementById("hiscore").hidden = true;
            document.getElementById("over").hidden = true;
            document.getElementById("game").hidden = false;
        },
        false
    );
    // document.getElementById("no").addEventListener(
    //     "click",
    //     () => {
    //         reset();
    //         document.getElementById("hiscore").hidden = true;
    //         document.getElementById("over").hidden = true;
    //         document.getElementById("game").hidden = false;
    //     },
    //     false
    // );
}

function checkHiScore() {
    var curr = -1;
    var player = 'NA';
    var records = hiscores.sort((a, b) => a.hiscore-b.hiscore);
    for (var i = 0; i &lt; records.length; i++) {
        if (score > records[i].hiscore) {
            curr = i;
        }
    }
    if (curr > -1) {
        document.getElementById("hiscore").hidden = false;
        document.getElementById("playersubmit").addEventListener(
            "click",
            () => {
                player = document.getElementById("playername").value;
            },
            false
        );
        records.insert(curr, {name: player, hiscore: score});
        records.shift();
        localStorage.setItem('Scores',  JSON.stringify(records));
    }
}

/**
 * Creates the initial population of genomes, each with random genes.
 */
function createInitialPopulation() {
    //inits the array
    genomes = [];
    //for a given population size
    for (var i = 0; i &lt; populationSize; i++) {
        //randomly initialize the 7 values that make up a genome
        //these are all weight values that are updated through evolution
        var genome = {
            //unique identifier for a genome
            id: Math.random(),
            //The weight of each row cleared by the given move. the more rows that are cleared, the more this weight increases
            rowsCleared: Math.random() - 0.5,
            //the absolute height of the highest column to the power of 1.5
            //added so that the algorithm can be able to detect if the blocks are stacking too high
            weightedHeight: Math.random() - 0.5,
            //The sum of all the column’s heights
            cumulativeHeight: Math.random() - 0.5,
            //the highest column minus the lowest column
            relativeHeight: Math.random() - 0.5,
            //the sum of all the empty cells that have a block above them (basically, cells that are unable to be filled)
            holes: Math.random() * 0.5,
            // the sum of absolute differences between the height of each column
            //(for example, if all the shapes on the grid lie completely flat, then the roughness would equal 0).
            roughness: Math.random() - 0.5,
        };
        //add them to the array
        genomes.push(genome);
    }
    evaluateNextGenome();
}

/**
 * Evaluates the next genome in the population. If there is none, evolves the population.
 */
function evaluateNextGenome() {
    //increment index in genome array
    currentGenome++;
    //If there is none, evolves the population.
    if (currentGenome == genomes.length) {
        evolve();
    }
    //load current gamestate
    loadState(roundState);
    //reset moves taken
    movesTaken = 0;
    //and make the next move
    makeNextMove();
}

/**
 * Evolves the entire population and goes to the next generation.
 */
function evolve() {

    console.log("Generation " + generation + " evaluated.");
    //reset current genome for new generation
    currentGenome = 0;
    //increment generation
    generation++;
    //resets the game
    reset();
    //gets the current game state
    roundState = getState();
    //sorts genomes in decreasing order of fitness values
    genomes.sort(function(a, b) {
        return b.fitness - a.fitness;
    });
    //add a copy of the fittest genome to the elites list
    archive.elites.push(clone(genomes[0]));
    console.log("Elite's fitness: " + genomes[0].fitness);

    //remove the tail end of genomes, focus on the fittest
    while(genomes.length > populationSize / 2) {
        genomes.pop();
    }
    //sum of the fitness for each genome
    var totalFitness = 0;
    for (var i = 0; i &lt; genomes.length; i++) {
        totalFitness += genomes[i].fitness;
    }

    //get a random index from genome array
    function getRandomGenome() {
        return genomes[randomWeightedNumBetween(0, genomes.length - 1)];
    }
    //create children array
    var children = [];
    //add the fittest genome to array
    children.push(clone(genomes[0]));
    //add population sized amount of children
    while (children.length &lt; populationSize) {
        //crossover between two random genomes to make a child
        children.push(makeChild(getRandomGenome(), getRandomGenome()));
    }
    //create new genome array
    genomes = [];
    //to store all the children in
    genomes = genomes.concat(children);
    //store this in our archive
    archive.genomes = clone(genomes);
    //and set current gen
    archive.currentGeneration = clone(generation);
    console.log(JSON.stringify(archive));
    //store archive, thanks JS localstorage! (short term memory)
    localStorage.setItem("archive", JSON.stringify(archive));
}

/**
 * Creates a child genome from the given parent genomes, and then attempts to mutate the child genome.
 * @param  {Genome} mum The first parent genome.
 * @param  {Genome} dad The second parent genome.
 * @return {Genome}     The child genome.
 */
function makeChild(mum, dad) {
    //init the child given two genomes (its 7 parameters + initial fitness value)
    var child = {
        //unique id
        id : Math.random(),
        //all these params are randomly selected between the mom and dad genome
        rowsCleared: randomChoice(mum.rowsCleared, dad.rowsCleared),
        weightedHeight: randomChoice(mum.weightedHeight, dad.weightedHeight),
        cumulativeHeight: randomChoice(mum.cumulativeHeight, dad.cumulativeHeight),
        relativeHeight: randomChoice(mum.relativeHeight, dad.relativeHeight),
        holes: randomChoice(mum.holes, dad.holes),
        roughness: randomChoice(mum.roughness, dad.roughness),
        //no fitness. yet.
        fitness: -1
    };
    //mutation time!

    //we mutate each parameter using our mutationstep
    if (Math.random() &lt; mutationRate) {
        child.rowsCleared = child.rowsCleared + Math.random() * mutationStep * 2 - mutationStep;
    }
    if (Math.random() &lt; mutationRate) {
        child.weightedHeight = child.weightedHeight + Math.random() * mutationStep * 2 - mutationStep;
    }
    if (Math.random() &lt; mutationRate) {
        child.cumulativeHeight = child.cumulativeHeight + Math.random() * mutationStep * 2 - mutationStep;
    }
    if (Math.random() &lt; mutationRate) {
        child.relativeHeight = child.relativeHeight + Math.random() * mutationStep * 2 - mutationStep;
    }
    if (Math.random() &lt; mutationRate) {
        child.holes = child.holes + Math.random() * mutationStep * 2 - mutationStep;
    }
    if (Math.random() &lt; mutationRate) {
        child.roughness = child.roughness + Math.random() * mutationStep * 2 - mutationStep;
    }
    return child;
}

/**
 * Returns an array of all the possible moves that could occur in the current state, rated by the parameters of the current genome.
 * @return {Array} An array of all the possible moves that could occur.
 */
function getAllPossibleMoves() {
    var lastState = getState();
    var possibleMoves = [];
    var iterations = 0;
    //for each possible rotation
    for (var rots = 0; rots &lt; 4; rots++) {

        var oldX = [];
        //for each iteration
        for (var t = -5; t &lt;= 5; t++) {
            iterations++;
            loadState(lastState);
            //rotate shape
            for (var j = 0; j &lt; rots; j++) {
                rotateShape();
            }
            //move left
            if (t &lt; 0) {
                for (var l = 0; l &lt; Math.abs(t); l++) {
                    moveLeft();
                }
            //move right
            } else if (t > 0) {
                for (var r = 0; r &lt; t; r++) {
                    moveRight();
                }
            }
            //if the shape has moved at all
            if (!contains(oldX, currentShape.x)) {
                //move it down
                var moveDownResults = moveDown();
                while (moveDownResults.moved) {
                    moveDownResults = moveDown();
                }
                //set the 7 parameters of a genome
                var algorithm = {
                    rowsCleared: moveDownResults.rowsCleared,
                    weightedHeight: Math.pow(getHeight(), 1.5),
                    cumulativeHeight: getCumulativeHeight(),
                    relativeHeight: getRelativeHeight(),
                    holes: getHoles(),
                    roughness: getRoughness()
                };
                //rate each move
                var rating = 0;
                rating += algorithm.rowsCleared * genomes[currentGenome].rowsCleared;
                rating += algorithm.weightedHeight * genomes[currentGenome].weightedHeight;
                rating += algorithm.cumulativeHeight * genomes[currentGenome].cumulativeHeight;
                rating += algorithm.relativeHeight * genomes[currentGenome].relativeHeight;
                rating += algorithm.holes * genomes[currentGenome].holes;
                rating += algorithm.roughness * genomes[currentGenome].roughness;
                //if the move loses the game, lower its rating
                if (moveDownResults.lose) {
                    rating -= 500;
                }
                //push all possible moves, with their associated ratings and parameter values to an array
                possibleMoves.push({rotations: rots, translation: t, rating: rating, algorithm: algorithm});
                //update the position of old X value
                oldX.push(currentShape.x);
            }
        }
    }
    //get last state
    loadState(lastState);
    //return array of all possible moves
    return possibleMoves;
}

/**
 * Returns the highest rated move in the given array of moves.
 * @param  {Array} moves An array of possible moves to choose from.
 * @return {Move}       The highest rated move from the moveset.
 */
function getHighestRatedMove(moves) {
    //start these values off small
    var maxRating = -10000000000000;
    var maxMove = -1;
    var ties = [];
    //iterate through the list of moves
    for (var index = 0; index &lt; moves.length; index++) {
        //if the current moves rating is higher than our maxrating
        if (moves[index].rating > maxRating) {
            //update our max values to include this moves values
            maxRating = moves[index].rating;
            maxMove = index;
            //store index of this move
            ties = [index];
        } else if (moves[index].rating == maxRating) {
            //if it ties with the max rating
            //add the index to the ties array
            ties.push(index);
        }
    }
    //eventually we'll set the highest move value to this move var
    var move = moves[ties[0]];
    //and set the number of ties
    move.algorithm.ties = ties.length;
    return move;
}

/**
 * Makes a move, which is decided upon using the parameters in the current genome.
 */
function makeNextMove() {
    //increment number of moves taken
    movesTaken++;
    //if its over the limit of moves
    if (movesTaken > moveLimit) {
        //update this genomes fitness value using the game score
        genomes[currentGenome].fitness = clone(score);
        //and evaluates the next genome
        evaluateNextGenome();
    } else {
        //time to make a move

        //we're going to re-draw, so lets store the old drawing
        var oldDraw = clone(draw);
        draw = false;
        //get all the possible moves
        var possibleMoves = getAllPossibleMoves();
        //lets store the current state since we will update it
        var lastState = getState();
        //whats the next shape to play
        nextShape();
        //for each possible move
        for (var i = 0; i &lt; possibleMoves.length; i++) {
            //get the best move. so were checking all the possible moves, for each possible move. moveception.
            var nextMove = getHighestRatedMove(getAllPossibleMoves());
            //add that rating to an array of highest rates moves
            possibleMoves[i].rating += nextMove.rating;
        }
        //load current state
        loadState(lastState);
        //get the highest rated move ever
        var move = getHighestRatedMove(possibleMoves);
        //then rotate the shape as it says too
        for (var rotations = 0; rotations &lt; move.rotations; rotations++) {
            rotateShape();
        }
        //and move left as it says
        if (move.translation &lt; 0) {
            for (var lefts = 0; lefts &lt; Math.abs(move.translation); lefts++) {
                moveLeft();
            }
            //and right as it says
        } else if (move.translation > 0) {
            for (var rights = 0; rights &lt; move.translation; rights++) {
                moveRight();
            }
        }
        //update our move algorithm
        if (inspectMoveSelection) {
            moveAlgorithm = move.algorithm;
        }
        //and set the old drawing to the current
        draw = oldDraw;
        //output the state to the screen
        output();
        //and update the score
        updateScore();
    }
}

/**
 * Updates the game.
 */
function update() {
    //if we have our AI turned on and the current genome is nonzero
    //make a move
    var results;
    if (ai &amp;&amp; currentGenome != -1) {
        //move the shape down
        results = moveDown();
        //if that didn't do anything
        if (!results.moved) {
            //if we lost
            if (results.lose) {
                //update the fitness
                genomes[currentGenome].fitness = clone(score);
                //move on to the next genome
                evaluateNextGenome();
            } else {
                //if we didnt lose, make the next move
                makeNextMove();
            }
        }
    } else {
    //else just move down
        results = moveDown();
    }
    //output the state to the screen
    output();
    //and update the score
    updateScore();
    lines += results.rowsCleared;
}

/**
 * Moves the current shape down if possible.
 * @return {Object} The results of the movement of the piece.
 */
function moveDown() {
    //array of possibilities
    var result = {lose: false, moved: true, rowsCleared: 0};
    //remove the shape, because we will draw a new one
    removeShape();
    //move it down the y axis
    currentShape.y++;
    //if it collides with the grid
    if (collides(grid, currentShape)) {
        //update its position
        currentShape.y--;
        //apply (stick) it to the grid
        applyShape();
        //move on to the next shape in the bag
        nextShape();
        //clear rows and get number of rows cleared
        result.rowsCleared = clearRows();
        //check again if this shape collides with our grid
        if (collides(grid, currentShape)) {
            //reset
            result.lose = true;
            pause = true;
            gameOver();
            // if (ai) {
            //     // pop up gameover screen with replay option
            // } else {
            //     gameOver();
            // }
        }
        result.moved = false;
    }
    //apply shape, update the score and output the state to the screen
    applyShape();
    updateScore();
    output();
    return result;
}

/**
 * Moves the current shape to the left if possible.
 */
function moveLeft() {
    //remove current shape, slide it over, if it collides though, slide it back
    removeShape();
    currentShape.x--;
    if (collides(grid, currentShape)) {
        currentShape.x++;
    }
    //apply the new shape
    applyShape();
}

/**
 * Moves the current shape to the right if possible.
 */
//same deal
function moveRight() {
    removeShape();
    currentShape.x++;
    if (collides(grid, currentShape)) {
        currentShape.x--;
    }
    applyShape();
}

/**
 * Rotates the current shape clockwise if possible.
 */
//slide it if we can, else return to original rotation
function rotateShape() {
    removeShape();
    currentShape.shape = rotate(currentShape.shape, 1);
    if (collides(grid, currentShape)) {
        currentShape.shape = rotate(currentShape.shape, 3);
    }
    applyShape();
}

/**
 * Clears any rows that are completely filled.
 */
function clearRows() {
    //empty array for rows to clear
    var rowsToClear = [];
    //for each row in the grid
    for (var row = 0; row &lt; grid.length; row++) {
        var containsEmptySpace = false;
        //for each column
        for (var col = 0; col &lt; grid[row].length; col++) {
            //if its empty
            if (grid[row][col] === 0) {
                //set this value to true
                containsEmptySpace = true;
            }
        }
        //if none of the columns in the row were empty
        if (!containsEmptySpace) {
            //add the row to our list, it's completely filled!
            rowsToClear.push(row);
        }
    }
    //increase score for up to 4 rows. it maxes out at 12000
    if (rowsToClear.length == 1) {
        score += 100;
    } else if (rowsToClear.length == 2) {
        score += 300;
    } else if (rowsToClear.length == 3) {
        score += 600;
    } else if (rowsToClear.length >= 4) {
        score += 1000;
    }
    //new array for cleared rows
    var rowsCleared = clone(rowsToClear.length);
    //for each value
    for (var toClear = rowsToClear.length - 1; toClear >= 0; toClear--) {
        //remove the row from the grid
        grid.splice(rowsToClear[toClear], 1);
    }
    //shift the other rows
    while (grid.length &lt; 20) {
        grid.unshift([0,0,0,0,0,0,0,0,0,0]);
    }
    //return the rows cleared
    return rowsCleared;
}

/**
 * Applies the current shape to the grid.
 */
function applyShape() {
    //for each value in the current shape (row x column)
    for (var row = 0; row &lt; currentShape.shape.length; row++) {
        for (var col = 0; col &lt; currentShape.shape[row].length; col++) {
            //if its non-empty
            if (currentShape.shape[row][col] !== 0) {
                //set the value in the grid to its value. Stick the shape in the grid!
                grid[currentShape.y + row][currentShape.x + col] = currentShape.shape[row][col];
            }
        }
    }
}

/**
 * Removes the current shape from the grid.
 */
//same deal but reverse
function removeShape() {
    for (var row = 0; row &lt; currentShape.shape.length; row++) {
        for (var col = 0; col &lt; currentShape.shape[row].length; col++) {
            if (currentShape.shape[row][col] !== 0) {
                grid[currentShape.y + row][currentShape.x + col] = 0;
            }
        }
    }
}

/**
 * Cycles to the next shape in the bag.
 */
function nextShape() {
    //increment the bag index
    bagIndex += 1;
    //if we're at the start or end of the bag
    if (bag.length === 0 || bagIndex == bag.length) {
        //generate a new bag of genomes
        generateBag();
    }
    //if almost at end of bag
    if (bagIndex == bag.length - 1) {
        //store previous seed
        var prevSeed = rndSeed;
        //generate upcoming shape
        upcomingShape = randomProperty(shapes);
        //set random seed
        rndSeed = prevSeed;
    } else {
        //get the next shape from our bag
        upcomingShape = shapes[bag[bagIndex + 1]];
    }
    //get our current shape from the bag
    currentShape.shape = shapes[bag[bagIndex]];
    //define its position
    currentShape.x = Math.floor(grid[0].length / 2) - Math.ceil(currentShape.shape[0].length / 2);
    currentShape.y = 0;
}

/**
 * Generates the bag of shapes.
 */
function generateBag() {
    bag = [];
    var contents = "";
    //7 shapes
    for (var i = 0; i &lt; 7; i++) {
        //generate shape randomly
        var shape = randomKey(shapes);
        while(contents.indexOf(shape) != -1) {
            shape = randomKey(shapes);
        }
        //update bag with generated shape
        bag[i] = shape;
        contents += shape;
    }
    //reset bag index
    bagIndex = 0;
}

/**
 * Resets the game.
 */
function reset() {
    score = 0;
    lines = 0;
    grid = [
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
    ];
    moves = 0;
    pause = true;
    generateBag();
    nextShape();
}

/**
 * Determines if the given grid and shape collide with one another.
 * @param  {Grid} scene  The grid to check.
 * @param  {Shape} object The shape to check.
 * @return {Boolean} Whether the shape and grid collide.
 */
function collides(scene, object) {
    //for the size of the shape (row x column)
    for (var row = 0; row &lt; object.shape.length; row++) {
        for (var col = 0; col &lt; object.shape[row].length; col++) {
            //if its not empty
            if (object.shape[row][col] !== 0) {
                //if it collides, return true
                if (scene[object.y + row] === undefined || scene[object.y + row][object.x + col] === undefined || scene[object.y + row][object.x + col] !== 0) {
                    return true;
                }
            }
        }
    }
    return false;
}

//for rotating a shape, how many times should we rotate
function rotate(matrix, times) {
    //for each time
    for (var t = 0; t &lt; times; t++) {
        //flip the shape matrix
        matrix = transpose(matrix);
        //and for the length of the matrix, reverse each column
        for (var i = 0; i &lt; matrix.length; i++) {
            matrix[i].reverse();
        }
    }
    return matrix;
}
//flip row x column to column x row
function transpose(array) {
    return array[0].map(function(col, i) {
        return array.map(function(row) {
            return row[i];
        });
    });
}

/**
 * Outputs the state to the screen.
 */
function output() {
    if (draw) {
        var output = document.getElementById("output");
        var space = "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;";
        var html = "&lt;h1>TETRIS&lt;/h1>&lt;h4>GROUP 18&lt;/h4>&lt;br />&lt;font color=#e5534b>var&lt;/font> &lt;font color=#539bf5>grid&lt;/font> = [";
        for (var i = 0; i &lt; grid.length; i++) {
            if (i === 0) {
                html += "[" + grid[i] + "]";
            } else {
                html += "&lt;br />" + space + "[" + grid[i] + "]";
            }
        }
        html += "];";
        for (var c = 0; c &lt; colors.length; c++) {
            html = replaceAll(html, "," + (c + 1), ",&lt;font color=\"" + colors[c] + "\">" + (c + 1) + "&lt;/font>");
            html = replaceAll(html, (c + 1) + ",", "&lt;font color=\"" + colors[c] + "\">" + (c + 1) + "&lt;/font>,");
        }
        output.innerHTML = html;
    }
}

/**
 * Updates the side information.
 */
function updateScore() {
    if (draw) {
        var scoreDetails = document.getElementById("score");
        var html = "&lt;br />&lt;br />&lt;br />&lt;br />&lt;h2>&amp;nbsp;&lt;/h2>&lt;h2>Score: " + score + "&lt;/h2>";
        html += "&lt;br />&lt;b>--Upcoming Shape--&lt;/b>";
        for (var i = 0; i &lt; upcomingShape.length; i++) {
            var next =replaceAll((upcomingShape[i] + ""), "0", "&amp;nbsp;");
            html += "&lt;br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;" + next;
        }
        for (var l = 0; l &lt; 4 - upcomingShape.length; l++) {
            html += "&lt;br />";
        }
        for (var c = 0; c &lt; colors.length; c++) {
            html = replaceAll(html, "," + (c + 1), ",&lt;font color=\"" + colors[c] + "\">" + (c + 1) + "&lt;/font>");
            html = replaceAll(html, (c + 1) + ",", "&lt;font color=\"" + colors[c] + "\">" + (c + 1) + "&lt;/font>,");
        }
        html += "&lt;br />Lines: " + lines;
        html += "&lt;br />Level: " + levels[speedIndex];
        html += "&lt;br />Type: " + (gameType ? "Extended" : "Normal");
        html += "&lt;br />Mode: " + (gameMode ? "AI" : "Player");
        if (ai) {
            if (inspectMoveSelection) {
                html += "&lt;br />&lt;pre style=\"font-size:12px\">" + JSON.stringify(moveAlgorithm, null, 2) + "&lt;/pre>";
            }
        }
        html = replaceAll(replaceAll(replaceAll(html, "&amp;nbsp;,", "&amp;nbsp;&amp;nbsp;"), ",&amp;nbsp;", "&amp;nbsp;&amp;nbsp;"), ",", "&amp;nbsp;");
        scoreDetails.innerHTML = html;
    }
}

/**
 * Returns the current game state in an object.
 * @return {State} The current game state.
 */
function getState() {
    var state = {
        grid: clone(grid),
        currentShape: clone(currentShape),
        upcomingShape: clone(upcomingShape),
        bag: clone(bag),
        bagIndex: clone(bagIndex),
        rndSeed: clone(rndSeed),
        score: clone(score)
    };
    return state;
}

/**
 * Loads the game state from the given state object.
 * @param  {State} state The state to load.
 */
function loadState(state) {
    grid = clone(state.grid);
    currentShape = clone(state.currentShape);
    upcomingShape = clone(state.upcomingShape);
    bag = clone(state.bag);
    bagIndex = clone(state.bagIndex);
    rndSeed = clone(state.rndSeed);
    score = clone(state.score);
    output();
    updateScore();
}

/**
 * Returns the cumulative height of all the columns.
 * @return {Number} The cumulative height.
 */
function getCumulativeHeight() {
    removeShape();
    var peaks = [20,20,20,20,20,20,20,20,20,20];
    for (var row = 0; row &lt; grid.length; row++) {
        for (var col = 0; col &lt; grid[row].length; col++) {
            if (grid[row][col] !== 0 &amp;&amp; peaks[col] === 20) {
                peaks[col] = row;
            }
        }
    }
    var totalHeight = 0;
    for (var i = 0; i &lt; peaks.length; i++) {
        totalHeight += 20 - peaks[i];
    }
    applyShape();
    return totalHeight;
}

/**
 * Returns the number of holes in the grid.
 * @return {Number} The number of holes.
 */
function getHoles() {
    removeShape();
    var peaks = [20,20,20,20,20,20,20,20,20,20];
    for (var row = 0; row &lt; grid.length; row++) {
        for (var col = 0; col &lt; grid[row].length; col++) {
            if (grid[row][col] !== 0 &amp;&amp; peaks[col] === 20) {
                peaks[col] = row;
            }
        }
    }
    var holes = 0;
    for (var x = 0; x &lt; peaks.length; x++) {
        for (var y = peaks[x]; y &lt; grid.length; y++) {
            if (grid[y][x] === 0) {
                holes++;
            }
        }
    }
    applyShape();
    return holes;
}

/**
 * Returns an array that replaces all the holes in the grid with -1.
 * @return {Array} The modified grid array.
 */
function getHolesArray() {
    var array = clone(grid);
    removeShape();
    var peaks = [20,20,20,20,20,20,20,20,20,20];
    for (var row = 0; row &lt; grid.length; row++) {
        for (var col = 0; col &lt; grid[row].length; col++) {
            if (grid[row][col] !== 0 &amp;&amp; peaks[col] === 20) {
                peaks[col] = row;
            }
        }
    }
    for (var x = 0; x &lt; peaks.length; x++) {
        for (var y = peaks[x]; y &lt; grid.length; y++) {
            if (grid[y][x] === 0) {
                array[y][x] = -1;
            }
        }
    }
    applyShape();
    return array;
}

/**
 * Returns the roughness of the grid.
 * @return {Number} The roughness of the grid.
 */
function getRoughness() {
    removeShape();
    var peaks = [20,20,20,20,20,20,20,20,20,20];
    for (var row = 0; row &lt; grid.length; row++) {
        for (var col = 0; col &lt; grid[row].length; col++) {
            if (grid[row][col] !== 0 &amp;&amp; peaks[col] === 20) {
                peaks[col] = row;
            }
        }
    }
    var roughness = 0;
    var differences = [];
    for (var i = 0; i &lt; peaks.length - 1; i++) {
        roughness += Math.abs(peaks[i] - peaks[i + 1]);
        differences[i] = Math.abs(peaks[i] - peaks[i + 1]);
    }
    applyShape();
    return roughness;
}

/**
 * Returns the range of heights of the columns on the grid.
 * @return {Number} The relative height.
 */
function getRelativeHeight() {
    removeShape();
    var peaks = [20,20,20,20,20,20,20,20,20,20];
    for (var row = 0; row &lt; grid.length; row++) {
        for (var col = 0; col &lt; grid[row].length; col++) {
            if (grid[row][col] !== 0 &amp;&amp; peaks[col] === 20) {
                peaks[col] = row;
            }
        }
    }
    applyShape();
    return Math.max.apply(Math, peaks) - Math.min.apply(Math, peaks);
}

/**
 * Returns the height of the biggest column on the grid.
 * @return {Number} The absolute height.
 */
function getHeight() {
    removeShape();
    var peaks = [20,20,20,20,20,20,20,20,20,20];
    for (var row = 0; row &lt; grid.length; row++) {
        for (var col = 0; col &lt; grid[row].length; col++) {
            if (grid[row][col] !== 0 &amp;&amp; peaks[col] === 20) {
                peaks[col] = row;
            }
        }
    }
    applyShape();
    return 20 - Math.min.apply(Math, peaks);
}

/**
 * Loads the fullevolvedarchive.
 *
 */
function loadArchive() {
    archive = fullyEvolvedArchive;
    genomes = clone(archive.genomes);
    populationSize = archive.populationSize;
    generation = archive.currentGeneration;
    currentGenome = 0;
    reset();
    roundState = getState();
    console.log("Archive loaded!");
}

/**
 * Array insert helper method.
 * @param  {Number} index the index at which to insert values.
 * param  {Any} values the values to insert in the array at position index.
 */
Array.prototype.insert = function(index) {
    this.splice.apply(this, [index, 0].concat(
        Array.prototype.slice.call(arguments, 1)));
    return this;
};

/**
 * Clones an object.
 * @param  {Object} obj The object to clone.
 * @return {Object}     The cloned object.
 */
function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}

/**
 * Returns a random property from the given object.
 * @param  {Object} obj The object to select a property from.
 * @return {Property}     A random property.
 */
function randomProperty(obj) {
    return(obj[randomKey(obj)]);
}

/**
 * Returns a random property key from the given object.
 * @param  {Object} obj The object to select a property key from.
 * @return {Property}     A random property key.
 */
function randomKey(obj) {
    var keys = Object.keys(obj);
    var i = seededRandom(0, keys.length);
    return keys[i];
}

function replaceAll(target, search, replacement) {
    return target.replace(new RegExp(search, 'g'), replacement);
}

/**
 * Returns a random number that is determined from a seeded random number generator.
 * @param  {Number} min The minimum number, inclusive.
 * @param  {Number} max The maximum number, exclusive.
 * @return {Number}     The generated random number.
 */
function seededRandom(min, max) {
    max = max || 1;
    min = min || 0;

    rndSeed = (rndSeed * 9301 + 49297) % 233280;
    var rnd = rndSeed / 233280;

    return Math.floor(min + rnd * (max - min));
}

function randomNumBetween(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}

function randomWeightedNumBetween(min, max) {
    return Math.floor(Math.pow(Math.random(), 2) * (max - min + 1) + min);
}

function randomChoice(propOne, propTwo) {
    if (Math.round(Math.random()) === 0) {
        return clone(propOne);
    } else {
        return clone(propTwo);
    }
}

function contains(a, obj) {
    var i = a.length;
    while (i--) {
        if (a[i] === obj) {
            return true;
        }
    }
    return false;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#applyShape">applyShape</a></li><li><a href="global.html#Card">Card</a></li><li><a href="global.html#clearRows">clearRows</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#collides">collides</a></li><li><a href="global.html#container">container</a></li><li><a href="global.html#createInitialPopulation">createInitialPopulation</a></li><li><a href="global.html#currentShape">currentShape</a></li><li><a href="global.html#evaluateNextGenome">evaluateNextGenome</a></li><li><a href="global.html#evolve">evolve</a></li><li><a href="global.html#generateBag">generateBag</a></li><li><a href="global.html#getAllPossibleMoves">getAllPossibleMoves</a></li><li><a href="global.html#getCumulativeHeight">getCumulativeHeight</a></li><li><a href="global.html#getHeight">getHeight</a></li><li><a href="global.html#getHighestRatedMove">getHighestRatedMove</a></li><li><a href="global.html#getHoles">getHoles</a></li><li><a href="global.html#getHolesArray">getHolesArray</a></li><li><a href="global.html#getRelativeHeight">getRelativeHeight</a></li><li><a href="global.html#getRoughness">getRoughness</a></li><li><a href="global.html#getState">getState</a></li><li><a href="global.html#grid">grid</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#Layout">Layout</a></li><li><a href="global.html#loadArchive">loadArchive</a></li><li><a href="global.html#loadState">loadState</a></li><li><a href="global.html#makeChild">makeChild</a></li><li><a href="global.html#makeNextMove">makeNextMove</a></li><li><a href="global.html#moveDown">moveDown</a></li><li><a href="global.html#moveLeft">moveLeft</a></li><li><a href="global.html#moveRight">moveRight</a></li><li><a href="global.html#nextShape">nextShape</a></li><li><a href="global.html#NoMatch">NoMatch</a></li><li><a href="global.html#output">output</a></li><li><a href="global.html#populationSize">populationSize</a></li><li><a href="global.html#randomKey">randomKey</a></li><li><a href="global.html#randomProperty">randomProperty</a></li><li><a href="global.html#removeShape">removeShape</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#rotateShape">rotateShape</a></li><li><a href="global.html#saveConfiguration">saveConfiguration</a></li><li><a href="global.html#Script">Script</a></li><li><a href="global.html#seededRandom">seededRandom</a></li><li><a href="global.html#settings">settings</a></li><li><a href="global.html#shapes">shapes</a></li><li><a href="global.html#update">update</a></li><li><a href="global.html#updateHiscores">updateHiscores</a></li><li><a href="global.html#updateScore">updateScore</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Wed Nov 02 2022 17:47:15 GMT+1100 (Australian Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
